 // -----------------------
//    Integrating   a  finitite state transducer with a PDA   to implemet a LEXER-PARSER
// Author:  Silvia Takahashi
// UNIVERSIDAD DE LOS ANDES
// -----------------------
 
 
 
using gold.structures.automaton.*
using gold.visualization.automaton.*

procedure main(args:String[]) begin
    Lexer = createTransducer()
	Parser2 = createAutomaton2()
	Parser = createAutomaton()  //  PDA de tres estados, que implementa diretamente la gramática
   stdin= java.util.Scanner(System.$in)
   print "Desea usar el parser  que implementa directamente la gramatica (1 para SI)"
  var mode:String
  mode := stdin.nextLine()
     
  // GAutomataFrame.show(Lexer)
   
  
  if mode.charAt(0) ='1' then   
     print  "usando el parser que implemeta direcatmente la gramatica"
     GAutomataFrame.show(Lexer)
     //GAutomataFrame.show(Parser)
     //testParser(Lexer,Parser)
   
   else 
     print  "usando el parser más eficaz"
    
    	GAutomataFrame.show(Lexer)
     	//GAutomataFrame.show(Parser2)
    
     //testParser(Lexer,Parser2)
    end  
    end
    
    
    

procedure testParser(M:ITransducer,P:IPushdownAutomaton) begin
	// M es el  analizador léxico
	// P es el  analizador sintáctico
	var sc:java.util.Scanner(System.$in)
	string="string"
	while string.length()>1 do
		print "----------------------------"
		print "Digite la cadena de entrada: (para termnar la cadena vacia)"
		string:=sc.nextLine()+" "   //Se le agrega un espacio al final para marcar el final de la entrada. El espacio también es un separador.
		result:=M.acceptsString(string)    
		tokenStream := M.getOutputString()
		print "Lexicamente, la cadena fue aceptada "+(result?"aceptada":"rechazada")+". Resultado: "+tokenStream 
	  
	  
		result:=P.acceptsString(tokenStream )  // Al parser se le pasa el token stream
		print "Sintacticamente, la cadena fue "+(result?"aceptada":"rechazada")
		
	end
	print("Termino la ejecucion")
end 

 

function createAutomaton():IPushdownAutomaton begin
	// Este autómata implementa  la  gramática directamente como se  ve en las notas de calse
	//
	//  E -> n
	//  E ->  v
	//  E ->  (+L)
	//  E ->  (*L)
	//  L ->  E
	//  L ->  L E
	
	
	Terms := {'(',')','+','*','v','n'}
	NonTerms := {'E','L'}
	Q:={"I","q","F"}
	Σ:=Terms
	Γ:=Terms ∪ NonTerms ∪ { '$'} 
	q₀:="I"
	F:={"F"}
	M:=GPushdownAutomaton(Q,Σ,Γ,q₀,F)
	
	M.delta("I","q","").push("$E")
	M.delta("q","F","").pop("$")
	
	for each x in {'(',')','+','*','v','n'} do
	  M.delta("q","q",""+x).pop(""+x)
	end
	M.delta("q","q","").changeTop("E","v")
	M.delta("q","q","").changeTop("E","n")
	M.delta("q","q","").changeTop("E",")L+(")
	M.delta("q","q","").changeTop("E",")L*(")
	M.delta("q","q","").changeTop("L","E")
	M.delta("q","q","").changeTop("L","EL")
return M
end

function createAutomaton2():IPushdownAutomaton begin
	
	// En lugar de usar la gramática definimos un autómata con más estados y no tan nodeterminísitico
	//  Con dos estados  El inicial que si lee v o n pasa al final
	//  Si le abrir paréntesis seguido de +.  empila un 1 y vuelva al mismo estado
	//  Si le abrir paréntesis seguido de *.  empila un 1 y vuelva al mismo estado
	// del estado 2 vuelve al estado 1 sin leer nada 
	//  Si en el estado 2   lee un cerrar parenteiss deempila 1
	
	
	
	
	Terms := {'(',')','+','*','v','n'}
	NonTerms := {'E','L'}
	Q:={"I","F"}
	Σ:={'(',')','+','*','v','n'}
	Γ:={'1'}
	q₀:="I"
	F:={"F"}
	M:=GPushdownAutomaton(Q,Σ,Γ,q₀,F)
	
	M.delta("I","I","(+").push("1")
	M.delta("I","I","(*").push("1")
	M.delta("I","F","v").ignore()
	M.delta("I","F","n").ignore()
	M.delta("F","F",")").pop("1")
	M.delta("F","I","").ignore()


return M
end

  
function createTransducer():ITransducer begin
	// Analizador léxico: Recibe una cadena de  letras minúsculas,  dígitos, paréntesis y epacios.
	// genera una cadena de paréntesis, suma,asterostico,ves y enes
	// reconoce las sigueintes palabras reservadas:  plus y times que  traduce en y * resspectivamente
	// los demás nombres  los traduce  a v; las cadenas de digito s  a n.
	
	Q:= {"I","Id", "p", "p_" ,"p_r", "p_re", "p_red", "f", "fi", "fin", "fin_", "fin_r", "fin_re", "fin_red", "c",
		"ca", "cap", "capa", "capac", "capaci", "capacid", "capacida", "capacidad", "capacidad:", "capacidad:=", "m", "ma", "mar", "marc", 
		"marca", "marcac", "marcaci", "marcacio", "marcacion", "marcacion_", "marcacion_i", "marcacion_i:", "marcacion_i:=",
		"v", "va", "var", "Nom", "s", "si", "sit", "siti", "sitio", "sitio:", "=", "Num", "Err"}
	
	Σ:=('a' ‥ 'z')∪('0' ‥ '9')∪{'_', ' ', '=', ':'}
	Out:={'P','n','F','V', 'S', 'C', 'I', 'Q', '=','#',':'} 
	q₀:="I"
	F:= {"I"}
	return 	GDeterministicTransducer(Q,Σ,Out,q₀,F,δ,g,h)
end

function δ(q,σ) begin
	if (q = "Err") then return "Err"
	elseif q="I" and σ='=' then return "="
	
   elseif q="I" and σ='p' then return "p"
   elseif q="p" and σ='_' then return "p_"
   	elseif q="p_" and σ='r' then return "p_r"
   	elseif q="p_r" and σ='e' then return "p_re"
   	elseif q="p_re" and σ='d' then return "p_red"
   	
   	elseif q="I" and σ='c' then return "c"
   elseif q="c" and σ='a' then return "ca"
   	elseif q="ca" and σ='p' then return "cap"
   	elseif q="cap" and σ='a' then return "capa"
   	elseif q="capa" and σ='c' then return "capac"
   elseif q="capac" and σ='i' then return "capaci"
   elseif q="capaci" and σ='d' then return "capacid"
   	elseif q="capacid" and σ='a' then return "capacida"
   	elseif q="capacida" and σ='d' then return "capacidad"
   	elseif q="capacidad" and σ=':' then return "capacidad:"
   	elseif q="capacidad:" and σ='=' then return "capacidad:="
   		
   	elseif q="I" and σ='m' then return "m"
   elseif q="m" and σ='a' then return "ma"
   elseif q="ma" and σ='r' then return "mar"
   	elseif q="mar" and σ='c' then return "marc"
   	elseif q="marc" and σ='a' then return "marca"
   	elseif q="marca" and σ='c' then return "marcac"
   elseif q="marcac" and σ='i' then return "marcaci"
   elseif q="marcaci" and σ='o' then return "marcacio"
   	elseif q="marcacio" and σ='n' then return "marcacion"
   	elseif q="marcacion" and σ='_' then return "marcacion_"
   	elseif q="marcacion_" and σ='i' then return "marcacion_i"
   	elseif q="marcacion_i" and σ=':' then return "marcacion_i:"
   	elseif q="marcacion_i:" and σ='=' then return "marcacion_i:="
   	
   	elseif q="I" and σ='s' then return "s"
	elseif q="s" and σ='i' then return "si"
	elseif q="si" and σ='t' then return "sit"
	elseif q="sit" and σ='i' then return "siti"
	elseif q="siti" and σ='o' then return "sitio"
	elseif q="sitio" and σ=':' then return "sitio:"
	elseif q="sitio:" and σ=' ' then return "Nom"
	
	
   	
   	elseif q="I" and σ='f' then return "f"
	elseif q="f" and σ='i' then return "fi"
	elseif q="fi" and σ='n' then return "fin"
	elseif q="fin" and σ='_' then return "fin_"
	elseif q="fin_" and σ='r' then return "fin_r"
	elseif q="fin_r" and σ='e' then return "fin_re"
	elseif q="fin_re" and σ='d' then return "fin_red"
		
	elseif q="I" and σ='v' then return "v"
   elseif q="v" and σ='a' then return "va"
   	elseif q="va" and σ='r' then return "var"

	elseif q="I" and σ ∈ ('a' ‥ 'z') then return "Nom"
	elseif q="Nom" and σ ∈ ('a' ‥ 'z')∪('0' ‥ '9') then return "Nom"
		
	elseif q="I" and σ ∈ ('0' ‥ '9') then return "Num"
	elseif q="Num" and σ ∈ ('0' ‥ '9') then return "Num"
	
	elseif	q="Num" and σ ∈ ('a' ‥ 'z') then return "Err"
	
	elseif  σ ∈ {' '} then return "I"

    else  return "Id"
    end	
end 



function g(q) begin
	return λ
end

function h(q,σ) begin
var s: String
s := λ

if q ∉ {"Err"} and σ ∈ {' '} then

		if σ ∉ {' '} then  s=String.valueOf(σ) end

      if q=="I" then return s
      elseif q=="p_red" then return "P"+s
      	elseif q=="sitio:" then return "S:"+s
      elseif q=="fin_red" then return "F"+s
      	elseif q=="var" then return "V"+s
      	elseif q=="capacidad:=" then return "CQ"+s
      	elseif q=="marcacion_i:=" then return "IQ"+s
      	
      	elseif q=="=" and σ==' ' then return "="+s
      	
      	
      elseif q=="Nom" then return "n"+s
      	elseif q=="Num" then return "#"+s
      else return s
      end
else return  λ

end
end